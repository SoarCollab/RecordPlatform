package cn.flying.minio.core;import cn.flying.minio.config.MinioProperties;import cn.flying.minio.config.NodeConfig;import io.minio.MinioClient;import jakarta.annotation.PreDestroy;import jakarta.annotation.Resource;import org.slf4j.Logger;import org.springframework.boot.context.event.ApplicationReadyEvent;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.cloud.context.environment.EnvironmentChangeEvent;import org.springframework.context.event.EventListener;import org.springframework.stereotype.Component;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.stream.Collectors;@Component@RefreshScopepublic class MinioClientManager {    private static final Logger log = org.slf4j.LoggerFactory.getLogger(MinioClientManager.class);    private final Map<String, MinioClient> clientCache = new ConcurrentHashMap<>();    private final Map<String, NodeConfig> nodeConfigCache = new ConcurrentHashMap<>();    @Resource    private MinioProperties minioProperties;    /**     * 在应用准备就绪后执行初始化 (使用 @EventListener)     */    @EventListener(ApplicationReadyEvent.class)    public void initializeClientsOnReady(ApplicationReadyEvent ignoredEvent) {        log.info("应用准备就绪。。。正在通过 @EventListener 初始化 MinIO 客户端");        reloadClients();    }    /**     * 监听 Nacos 配置刷新事件，重新加载客户端     */    @EventListener(EnvironmentChangeEvent.class)    public void onEnvironmentChangeEvent(EnvironmentChangeEvent event) {        log.info("检测到配置变更事件，变更的配置键: {}", event.getKeys());        // 检查是否包含MinIO相关的配置变更        boolean hasMinioConfigChange = event.getKeys().stream()                .anyMatch(key -> key.startsWith("minio."));        if (hasMinioConfigChange) {            log.info("检测到MinIO相关配置变更，重新加载客户端...");            reloadClients();        } else {            log.debug("配置变更不涉及MinIO，跳过客户端重新加载");        }    }    /**     * 重新加载所有 MinIO 客户端     */    public synchronized void reloadClients() {        log.info("根据当前配置重新加载 MinIO 客户端...");        Map<String, NodeConfig> newNodeConfigs = new ConcurrentHashMap<>();        Map<String, MinioClient> newClientCache = new ConcurrentHashMap<>();        // 检查 minioProperties 是否为 null        if (minioProperties == null) {            log.error("MinioProperties bean 在重新加载期间为 null。无法加载客户端。");            return;        }        // 检查 nodes 列表是否为 null        if (minioProperties.getNodes() == null) {            log.warn("MinioProperties中'nodes'列表为null。不会加载任何客户端。");        } else {            log.info("在Nacos配置中找到 {} 个节点", minioProperties.getNodes().size());            for (NodeConfig nodeConfig : minioProperties.getNodes()) {                if (nodeConfig.getName() == null || nodeConfig.getName().isBlank()) {                    log.error("发现缺少名称的 MinIO 节点配置，跳过。。。");                    continue;                }                newNodeConfigs.put(nodeConfig.getName(), nodeConfig);                try {                    MinioClient existingClient = clientCache.get(nodeConfig.getName());                    NodeConfig oldConfig = nodeConfigCache.get(nodeConfig.getName());                    // 如果配置没有变化，并且已有客户端，则复用                    if (oldConfig != null && oldConfig.equals(nodeConfig) && existingClient != null) {                        log.debug("为节点重用现有的 MinIO 客户端: {}", nodeConfig.getName());                        newClientCache.put(nodeConfig.getName(), existingClient);                    } else {                        log.info("为节点创建/更新 MinIO 客户端: {}", nodeConfig.getName()); // 改为 INFO 级别方便观察                        MinioClient newClient = MinioClient.builder()                                .endpoint(nodeConfig.getEndpoint())                                .credentials(nodeConfig.getAccessKey(), nodeConfig.getSecretKey())                                .build();                        // 尝试连接 (可选)                        try {                            newClient.listBuckets(); // Basic health check                            log.info("已成功连接到更新的 MinIO 节点: {}", nodeConfig.getName());                        } catch (Exception e) {                            log.warn("无法连接或验证更新的 MinIO 节点 '{}': {}", nodeConfig.getName(), e.getMessage());                        }                        newClientCache.put(nodeConfig.getName(), newClient);                        // 如果存在旧客户端，需要关闭旧的（如果 MinIO Client 需要关闭的话）                        // MinIO Java SDK 的 Client 通常不需要显式关闭，它管理内部的 HTTP 连接池                    }                } catch (Exception e) {                    log.error("为节点创建/更新 MinIO 客户端时出错'{}': {}", nodeConfig.getName(), e.getMessage(), e);                }            }        }        // 找出需要移除的旧客户端（在旧配置中有，新配置中没有的）        Set<String> nodesToRemove = nodeConfigCache.keySet().stream()                .filter(name -> !newNodeConfigs.containsKey(name))                .collect(Collectors.toSet());        if (!nodesToRemove.isEmpty()) {            log.info("删除不再处于配置中的节点的客户端: {}", nodesToRemove);            nodesToRemove.forEach(name -> {                // 关闭旧客户端（如果需要）                clientCache.remove(name);                nodeConfigCache.remove(name);            });        }        // 更新缓存        // 使用 ConcurrentHashMap 的原子性操作        this.clientCache.clear();        this.clientCache.putAll(newClientCache);        this.nodeConfigCache.clear();        this.nodeConfigCache.putAll(newNodeConfigs);        log.info("已完成重新加载MinIO节点。当前活跃节点数量: {}", this.clientCache.size());    }    /**     * 应用关闭前清理资源 (如果 MinIOClient 需要关闭)     * MinIO Client 一般不需要显式关闭     */    @PreDestroy    public void cleanup() {        log.info("关闭MinioClientManager...");        // 如果 MinioClient 实例需要关闭资源，可以在这里遍历 clientCache 并关闭        clientCache.clear();        nodeConfigCache.clear();    }    /**     * 根据物理节点名称获取 MinioClient 实例     *     * @param nodeName 物理节点名称 (在 application.yml 中配置的 name)     * @return MinioClient 实例，如果找不到或初始化失败则可能返回 null     */    public MinioClient getClient(String nodeName) {        MinioClient client = clientCache.get(nodeName);        if (client == null) {            log.error("未找到或未为节点名称配置 MinIO 客户端: {}. 检查 Nacos 配置和节点状态。", nodeName);        }        return client;    }    /**     * 根据物理节点名称获取节点配置信息     *     * @param nodeName 物理节点名称     * @return 节点配置信息，如果找不到则返回 null     */    public NodeConfig getNodeConfig(String nodeName) {        NodeConfig config = nodeConfigCache.get(nodeName);        if (config == null) {            log.warn("未找到节点 {} 对应的的节点配置，请检查 Nacos 配置.", nodeName);        }        return config;    }    /**     * 获取所有当前有效的 MinIO 客户端     * 主要用于监控组件遍历检查状态     *     * @return 物理节点名称到 MinioClient 的映射     */    public Map<String, MinioClient> getAllClients() {        return clientCache;    }    /**     * 获取所有当前有效的物理节点配置信息     *     * @return 物理节点名称到 NodeConfig 的映射     */    public Map<String, NodeConfig> getAllNodeConfigs() {        log.debug("获取所有节点配置，当前缓存大小: {}, 配置详情: {}", nodeConfigCache.size(), nodeConfigCache.keySet());        if (nodeConfigCache.isEmpty()) {            log.warn("节点配置缓存为空，尝试重新加载配置...");            reloadClients();        }        return nodeConfigCache;    }    /**     * 手动刷新配置（用于调试和故障排除）     */    public void manualRefresh() {        log.info("手动触发配置刷新...");        reloadClients();    }}