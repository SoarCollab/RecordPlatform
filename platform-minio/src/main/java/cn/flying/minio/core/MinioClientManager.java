package cn.flying.minio.core;import cn.flying.minio.config.MinioProperties;import cn.flying.minio.config.NodeConfig;import io.minio.MinioClient;import jakarta.annotation.PreDestroy;import jakarta.annotation.Resource;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.context.config.annotation.RefreshScope;import org.springframework.cloud.context.environment.EnvironmentChangeEvent;import org.springframework.context.event.EventListener;import org.springframework.boot.context.event.ApplicationReadyEvent;import org.springframework.stereotype.Component;import java.util.Map;import java.util.Set;import java.util.concurrent.ConcurrentHashMap;import java.util.stream.Collectors;@Slf4j@Component@RefreshScopepublic class MinioClientManager {    @Resource    private MinioProperties minioProperties;    private final Map<String, MinioClient> clientCache = new ConcurrentHashMap<>();    private final Map<String, NodeConfig> nodeConfigCache = new ConcurrentHashMap<>();    /**     * 在应用准备就绪后执行初始化 (使用 @EventListener)     */    @EventListener(ApplicationReadyEvent.class)    public void initializeClientsOnReady(ApplicationReadyEvent ignoredEvent) {        log.info("应用准备就绪。。。正在通过 @EventListener 初始化 MinIO 客户端");        reloadClients();    }    /**     * 监听 Nacos 配置刷新事件，重新加载客户端     */    @EventListener(EnvironmentChangeEvent.class)    public void onEnvironmentChangeEvent() {        log.info("检测到MinIO相关配置变更，重新加载客户端...");        reloadClients();    }    /**     * 重新加载所有 MinIO 客户端     */    public synchronized void reloadClients() {        log.info("根据当前配置重新加载 MinIO 客户端...");        Map<String, NodeConfig> newNodeConfigs = new ConcurrentHashMap<>();        Map<String, MinioClient> newClientCache = new ConcurrentHashMap<>();        // 检查 minioProperties 是否为 null        if (minioProperties == null) {            log.error("MinioProperties bean 在重新加载期间为 null。无法加载客户端。");            return;        }        // 检查 nodes 列表是否为 null        if (minioProperties.getNodes() == null) {            log.warn("MinioProperties中'nodes'列表为null。不会加载任何客户端。");        } else {            log.info("在Nacos配置中找到 {} 个节点", minioProperties.getNodes().size());            for (NodeConfig nodeConfig : minioProperties.getNodes()) {                if (nodeConfig.getName() == null || nodeConfig.getName().isBlank()) {                    log.error("发现缺少名称的 MinIO 节点配置，跳过。。。");                    continue;                }                newNodeConfigs.put(nodeConfig.getName(), nodeConfig);                try {                    MinioClient existingClient = clientCache.get(nodeConfig.getName());                    NodeConfig oldConfig = nodeConfigCache.get(nodeConfig.getName());                    // 如果配置没有变化，并且已有客户端，则复用                    if (oldConfig != null && oldConfig.equals(nodeConfig) && existingClient != null) {                        log.debug("为节点重用现有的 MinIO 客户端: {}", nodeConfig.getName());                        newClientCache.put(nodeConfig.getName(), existingClient);                    } else {                        log.info("为节点创建/更新 MinIO 客户端: {}", nodeConfig.getName()); // 改为 INFO 级别方便观察                        MinioClient newClient = MinioClient.builder()                                .endpoint(nodeConfig.getEndpoint())                                .credentials(nodeConfig.getAccessKey(), nodeConfig.getSecretKey())                                .build();                        // 尝试连接 (可选)                        try {                            newClient.listBuckets(); // Basic health check                            log.info("已成功连接到更新的 MinIO 节点: {}", nodeConfig.getName());                        } catch (Exception e) {                            log.warn("无法连接或验证更新的 MinIO 节点 '{}': {}", nodeConfig.getName(), e.getMessage());                        }                        newClientCache.put(nodeConfig.getName(), newClient);                        // 如果存在旧客户端，需要关闭旧的（如果 MinIO Client 需要关闭的话）                        // MinIO Java SDK 的 Client 通常不需要显式关闭，它管理内部的 HTTP 连接池                    }                } catch (Exception e) {                    log.error("为节点创建/更新 MinIO 客户端时出错'{}': {}", nodeConfig.getName(), e.getMessage(), e);                }            }        }        // 找出需要移除的旧客户端（在旧配置中有，新配置中没有的）        Set<String> nodesToRemove = nodeConfigCache.keySet().stream()                .filter(name -> !newNodeConfigs.containsKey(name))                .collect(Collectors.toSet());        if (!nodesToRemove.isEmpty()) {            log.info("删除不再处于配置中的节点的客户端: {}", nodesToRemove);            nodesToRemove.forEach(name -> {                // 关闭旧客户端（如果需要）                clientCache.remove(name);                nodeConfigCache.remove(name);            });        }        // 更新缓存        // 使用 ConcurrentHashMap 的原子性操作        this.clientCache.clear();        this.clientCache.putAll(newClientCache);        this.nodeConfigCache.clear();        this.nodeConfigCache.putAll(newNodeConfigs);        log.info("已完成重新加载MinIO节点。当前活跃节点数量: {}", this.clientCache.size());    }    /**     * 应用关闭前清理资源 (如果 MinIOClient 需要关闭)     * MinIO Client 一般不需要显式关闭     */    @PreDestroy    public void cleanup() {        log.info("关闭MinioClientManager...");        // 如果 MinioClient 实例需要关闭资源，可以在这里遍历 clientCache 并关闭        clientCache.clear();        nodeConfigCache.clear();    }    /**     * 根据物理节点名称获取 MinioClient 实例     *     * @param nodeName 物理节点名称 (在 application.yml 中配置的 name)     * @return MinioClient 实例，如果找不到或初始化失败则可能返回 null     */    public MinioClient getClient(String nodeName) {        MinioClient client = clientCache.get(nodeName);        if (client == null) {            log.error("未找到或未为节点名称配置 MinIO 客户端: {}. 检查 Nacos 配置和节点状态。", nodeName);        }        return client;    }    /**     * 根据物理节点名称获取节点配置信息     * @param nodeName 物理节点名称     * @return 节点配置信息，如果找不到则返回 null     */    public NodeConfig getNodeConfig(String nodeName) {        NodeConfig config = nodeConfigCache.get(nodeName);        if (config == null) {            log.warn("未找到节点 {} 对应的的节点配置，请检查 Nacos 配置.", nodeName);        }        return config;    }    /**     * 获取所有当前有效的 MinIO 客户端     * 主要用于监控组件遍历检查状态     * @return 物理节点名称到 MinioClient 的映射     */    public Map<String, MinioClient> getAllClients() {        return clientCache;    }    /**     * 获取所有当前有效的物理节点配置信息     * @return 物理节点名称到 NodeConfig 的映射     */    public Map<String, NodeConfig> getAllNodeConfigs() {        return nodeConfigCache;    }}